# Advent of Code 2020 - Analysis and Progress

## Progress Tracker

| Day | Title | Category | Part 1 | Part 2 |
|-----|-------|----------|--------|--------|
| 1 | Report Repair | Simple | [x] 982464 | [x] 162292410 |
| 2 | Password Philosophy | Simple | [x] 477 | [x] 686 |
| 3 | Toboggan Trajectory | Simple | [x] 242 | [x] 2265549792 |
| 4 | Passport Processing | Simple | [x] 235 | [x] 194 |
| 5 | Binary Boarding | Simple | [x] 816 | [x] 539 |
| 6 | Custom Customs | Simple | [x] 7283 | [x] 3520 |
| 7 | Handy Haversacks | Moderate | [x] 332 | [x] 10875 |
| 8 | Handheld Halting | Simple | [x] 1584 | [x] 920 |
| 9 | Encoding Error | Simple | [x] 85848519 | [x] 13414198 |
| 10 | Adapter Array | Moderate | [x] 2277 | [x] 37024595836928 |
| 11 | Seating System | Moderate | [x] 2261 | [x] 2039 |
| 12 | Rain Risk | Simple | [x] 2458 | [x] 145117 |
| 13 | Shuttle Search | Complex | [x] 2092 | [x] 702970661767766 |
| 14 | Docking Data | Moderate | [x] 15403588588538 | [x] 3260587250457 |
| 15 | Rambunctious Recitation | Simple | [x] 1428 | [x] 3718541 |
| 16 | Ticket Translation | Moderate | [x] 23009 | [x] 10458887314153 |
| 17 | Conway Cubes | Moderate | [x] 333 | [x] 2676 |
| 18 | Operation Order | Moderate | [x] 1451467526514 | [x] 224973686321527 |
| 19 | Monster Messages | Complex | [x] 222 | [x] 339 |
| 20 | Jurassic Jigsaw | Complex | [x] 27803643063307 | [x] 1644 |
| 21 | Allergen Assessment | Moderate | [x] 1685 | [x] ntft,nhx,kfxr,xmhsbd,rrjb,xzhxj,chbtp,cqvc |
| 22 | Crab Combat | Moderate | [x] 33400 | [x] 33745 |
| 23 | Crab Cups | Complex | [x] 82934675 | [x] 474600314018 |
| 24 | Lobby Layout | Moderate | [x] 450 | [x] 4059 |
| 25 | Combo Breaker | Simple | [x] 16311885 | ⭐ |

**Summary:** 11 Simple ✅, 10 Moderate ✅, 4 Complex ✅ - **All 25 days complete!**

---

## 2020 Overview: Vacation Gone Wrong

2020's theme follows your attempt to take a vacation to a tropical island, with each day presenting obstacles along the way - from airport problems to ferry issues to tropical island adventures. This year features a mix of parsing challenges, simulation problems, and mathematical puzzles, with less emphasis on building a single system (like 2019's Intcode) and more variety in problem types.

---

## Day-by-Day Analysis

### Day 1: Report Repair
**Category:** Simple

**Summary:** Find entries in an expense report that sum to 2020. Part 1 asks for two entries, Part 2 asks for three entries.

**Approach:**
- Parse input as list of integers
- Part 1: Find two numbers that sum to 2020, return their product
- Part 2: Find three numbers that sum to 2020, return their product

**Key Concepts:** Two-sum/Three-sum problem, nested iteration or set lookup

**Elixir Tips:**
```elixir
# Simple approach with for comprehension
for i <- values, j <- values, i + j == 2020, do: i * j
# Or use a set for O(n) lookup
set = MapSet.new(values)
Enum.find(values, fn x -> MapSet.member?(set, 2020 - x) end)
```

---

### Day 2: Password Philosophy
**Category:** Simple

**Summary:** Validate passwords against policies. Part 1 interprets the numbers as min/max character counts. Part 2 interprets them as positions (exactly one must match).

**Approach:**
- Parse each line: `min-max char: password`
- Part 1: Count occurrences of char, check if within range
- Part 2: Check if exactly one of the two positions contains the char (XOR)

**Key Concepts:** String parsing, regex, counting, XOR logic

---

### Day 3: Toboggan Trajectory
**Category:** Simple

**Summary:** Navigate a repeating grid pattern (forest map), counting trees hit. Part 1: single slope (right 3, down 1). Part 2: multiple slopes, multiply results.

**Approach:**
- Parse grid, handle horizontal wrapping with modulo
- Count trees (#) encountered following each slope
- Part 2: Try slopes (1,1), (3,1), (5,1), (7,1), (1,2), multiply tree counts

**Key Concepts:** Grid traversal, modular arithmetic, coordinate math

---

### Day 4: Passport Processing
**Category:** Simple

**Summary:** Validate passport data. Part 1: Check required fields are present. Part 2: Validate field values with specific rules.

**Approach:**
- Parse passports (blank-line separated), extract key:value pairs
- Part 1: Check all required fields exist (byr, iyr, eyr, hgt, hcl, ecl, pid)
- Part 2: Add validation rules for each field (year ranges, height units, color format, etc.)

**Key Concepts:** Parsing, validation, regex

---

### Day 5: Binary Boarding
**Category:** Simple

**Summary:** Boarding passes encode seat positions in binary (F/B for row, L/R for column). Part 1: Find highest seat ID. Part 2: Find your missing seat.

**Approach:**
- Convert F/B to 0/1, L/R to 0/1 - it's just binary!
- Seat ID = row * 8 + column
- Part 1: Find maximum seat ID
- Part 2: Find the gap in the list of seat IDs

**Key Concepts:** Binary numbers, String.replace, integer parsing

**Elixir Tips:**
```elixir
pass
|> String.replace(~r/[FL]/, "0")
|> String.replace(~r/[BR]/, "1")
|> String.to_integer(2)
```

---

### Day 6: Custom Customs
**Category:** Simple

**Summary:** Custom declaration forms with yes/no questions (a-z). Part 1: Count questions where anyone answered yes. Part 2: Count where everyone answered yes.

**Approach:**
- Split by blank lines into groups
- Part 1: Union of all characters in group
- Part 2: Intersection of all characters in group

**Key Concepts:** Set operations, MapSet.union, MapSet.intersection

---

### Day 7: Handy Haversacks
**Category:** Moderate

**Summary:** Bag rules specify which bags can contain which other bags (with quantities). Part 1: How many bag colors can eventually contain shiny gold? Part 2: How many bags inside one shiny gold bag?

**Approach:**
- Parse rules into a graph structure (parent → children with counts)
- Part 1: Build reverse graph, BFS/DFS from shiny gold to find all ancestors
- Part 2: Recursive count of bags inside shiny gold

**Key Concepts:** Graph traversal, recursion, parsing complex rules

**Why Moderate:** Parsing is tricky, and Part 2 requires careful recursive counting with multiplication.

---

### Day 8: Handheld Halting
**Category:** Simple

**Summary:** Simple VM with acc, jmp, nop instructions. Part 1: Find accumulator value before first repeated instruction. Part 2: Fix one instruction to make program terminate normally.

**Approach:**
- Parse instructions into list of {opcode, arg} tuples
- Part 1: Run until instruction pointer repeats, return accumulator
- Part 2: Try swapping each jmp↔nop until program terminates (reaches end)

**Key Concepts:** Virtual machine, loop detection, brute force

---

### Day 9: Encoding Error
**Category:** Simple

**Summary:** XMAS encryption - each number should be sum of two from previous 25. Part 1: Find first invalid number. Part 2: Find contiguous range that sums to Part 1 answer.

**Approach:**
- Part 1: Sliding window of 25, check each number is sum of two in window
- Part 2: Sliding window (two-pointer) to find contiguous sum

**Key Concepts:** Sliding window, two-sum validation

---

### Day 10: Adapter Array
**Category:** Moderate

**Summary:** Chain joltage adapters (each accepts 1-3 jolts lower). Part 1: Count 1-jolt and 3-jolt differences. Part 2: Count total valid arrangements.

**Approach:**
- Sort adapters, add 0 (outlet) and max+3 (device)
- Part 1: Count differences between consecutive adapters
- Part 2: Dynamic programming - count ways to reach each adapter

**Key Concepts:** Sorting, counting, dynamic programming

**Why Moderate:** Part 2 requires DP insight; brute force is too slow.

---

### Day 11: Seating System
**Category:** Moderate

**Summary:** Cellular automaton with seating rules. Part 1: Consider 8 adjacent seats. Part 2: Consider first visible seat in each direction.

**Approach:**
- Parse grid of seats (L=empty, #=occupied, .=floor)
- Part 1: Apply rules based on adjacent occupied count (≥4 becomes empty)
- Part 2: Look in each direction until hitting a seat (not floor)
- Simulate until stable, count occupied seats

**Key Concepts:** Cellular automata, simulation, grid operations

**Why Moderate:** Part 2's line-of-sight logic is tricky.

---

### Day 12: Rain Risk
**Category:** Simple

**Summary:** Navigate a ship with N/S/E/W/L/R/F instructions. Part 1: Ship moves and rotates. Part 2: Waypoint-based movement.

**Approach:**
- Track position and direction/waypoint
- Part 1: N/S/E/W move ship, L/R rotate ship, F moves forward
- Part 2: N/S/E/W move waypoint, L/R rotate waypoint around ship, F moves toward waypoint
- Calculate Manhattan distance from origin

**Key Concepts:** 2D navigation, rotation, coordinate geometry

---

### Day 13: Shuttle Search
**Category:** Complex

**Summary:** Bus schedules - buses depart at multiples of their ID. Part 1: Find earliest bus. Part 2: Find timestamp where buses depart at consecutive times matching their positions.

**Approach:**
- Part 1: For each bus, find next departure after timestamp
- Part 2: Chinese Remainder Theorem - find t where (t + offset) ≡ 0 (mod bus_id)

**Key Concepts:** Modular arithmetic, Chinese Remainder Theorem

**Why Complex:** Part 2 requires CRT or clever sieving - can't brute force.

---

### Day 14: Docking Data
**Category:** Moderate

**Summary:** Bitmask operations. Part 1: Mask values before writing to memory. Part 2: Mask addresses (X = floating, writes to all combinations).

**Approach:**
- Parse mask and mem[addr] = value instructions
- Part 1: Apply mask to value (0/1 overwrite, X unchanged)
- Part 2: Apply mask to address (0 unchanged, 1 overwrite, X floating)
- Handle floating bits by generating all combinations

**Key Concepts:** Bit manipulation, combinatorics

**Why Moderate:** Part 2's floating bit logic requires generating 2^n addresses.

---

### Day 15: Rambunctious Recitation
**Category:** Simple

**Summary:** Memory game - say 0 if number is new, else say how many turns apart it was last spoken. Part 1: 2020th number. Part 2: 30000000th number.

**Approach:**
- Track last turn each number was spoken (use map/array)
- Iterate through turns, apply rules
- Part 2 is same logic, just more iterations (need efficient lookup)

**Key Concepts:** Simulation, hash map for O(1) lookup

**Elixir Tips:** Use a Map for tracking; avoid list operations.

---

### Day 16: Ticket Translation
**Category:** Moderate

**Summary:** Ticket fields with valid ranges. Part 1: Find completely invalid values. Part 2: Determine which field is which column.

**Approach:**
- Parse rules (field: range1 or range2), your ticket, nearby tickets
- Part 1: Sum values not valid for any field
- Part 2: Filter valid tickets, determine possible fields per column, reduce by elimination

**Key Concepts:** Validation, constraint satisfaction, elimination

**Why Moderate:** Part 2 requires logical deduction to assign fields.

---

### Day 17: Conway Cubes
**Category:** Moderate

**Summary:** 3D (Part 1) and 4D (Part 2) Game of Life. Run 6 cycles, count active cubes.

**Approach:**
- Store active cubes as set of coordinates
- Each cycle: check all active cubes and their neighbors
- Apply rules: active stays if 2-3 neighbors active, inactive becomes active if exactly 3 neighbors

**Key Concepts:** Cellular automata, N-dimensional coordinates, set operations

**Why Moderate:** Need to handle expanding grid and higher dimensions.

---

### Day 18: Operation Order
**Category:** Moderate

**Summary:** Math expressions with different precedence rules. Part 1: Left-to-right (+ and * same precedence). Part 2: Addition before multiplication.

**Approach:**
- Part 1: Evaluate left-to-right, handle parentheses recursively
- Part 2: Use shunting-yard algorithm or recursive descent with different precedence

**Key Concepts:** Expression parsing, operator precedence, recursion

**Why Moderate:** Requires understanding of parsing techniques.

---

### Day 19: Monster Messages
**Category:** Complex

**Summary:** Match messages against grammar rules. Part 1: Simple rules. Part 2: Rules with recursion (loops).

**Approach:**
- Parse rules into grammar (terminals and non-terminals)
- Part 1: Build regex or recursive matcher
- Part 2: Handle cyclic rules (8: 42 | 42 8, 11: 42 31 | 42 11 31)

**Key Concepts:** Context-free grammars, recursive descent parsing, regex

**Why Complex:** Part 2's recursive rules require careful handling (can't use simple regex).

---

### Day 20: Jurassic Jigsaw
**Category:** Complex

**Summary:** Reassemble image tiles by matching edges (with rotation/flip). Part 1: Find corner tiles. Part 2: Assemble image and find sea monsters.

**Approach:**
- Parse tiles, compute all edge variations (8 orientations)
- Part 1: Corner tiles have 2 unique edges (don't match other tiles)
- Part 2: Assemble full image, strip borders, search for pattern

**Key Concepts:** 2D transformations, edge matching, pattern search

**Why Complex:** Many moving parts - rotations, flips, assembly, pattern matching.

---

### Day 21: Allergen Assessment
**Category:** Moderate

**Summary:** Match allergens to ingredients by process of elimination. Part 1: Count appearances of safe ingredients. Part 2: List dangerous ingredients.

**Approach:**
- For each allergen, find intersection of ingredients in all foods containing it
- Iteratively eliminate unique mappings
- Part 1: Count non-allergen ingredients
- Part 2: Sort by allergen name, join ingredient names

**Key Concepts:** Set intersection, constraint satisfaction

---

### Day 22: Crab Combat
**Category:** Moderate

**Summary:** Card game (War variant). Part 1: Basic rules. Part 2: Recursive Combat with sub-games.

**Approach:**
- Part 1: Simulate drawing, winner takes both cards
- Part 2: Add recursion - if both have enough cards, play sub-game to determine round winner
- Track seen states to prevent infinite games

**Key Concepts:** Simulation, recursion, cycle detection

**Why Moderate:** Part 2's recursive sub-games require careful state management.

---

### Day 23: Crab Cups
**Category:** Complex

**Summary:** Circle manipulation game. Part 1: 100 moves. Part 2: 1 million cups, 10 million moves.

**Approach:**
- Part 1: Can use list/array rotation
- Part 2: Need linked list (each cup points to next)
  - Use array where index = cup label, value = next cup label
  - O(1) operations for picking up and inserting cups

**Key Concepts:** Circular linked list, efficient data structures

**Why Complex:** Part 2 requires O(1) operations; naive approach too slow.

---

### Day 24: Lobby Layout
**Category:** Moderate

**Summary:** Hexagonal grid with tile flipping. Part 1: Follow paths, count black tiles. Part 2: Cellular automaton on hex grid.

**Approach:**
- Use cube coordinates or axial coordinates for hex grid
- Part 1: Parse directions (e, se, sw, w, nw, ne), track flipped tiles
- Part 2: Apply Game of Life rules on hex grid for 100 days

**Key Concepts:** Hexagonal grids, cellular automata, coordinate systems

**Hex Coordinate Tips:**
```elixir
# Axial coordinates (q, r)
directions = %{
  "e" => {1, 0}, "w" => {-1, 0},
  "se" => {0, 1}, "nw" => {0, -1},
  "sw" => {-1, 1}, "ne" => {1, -1}
}
```

---

### Day 25: Combo Breaker
**Category:** Simple

**Summary:** Break RFID encryption by finding loop sizes. Given two public keys, find the shared encryption key.

**Approach:**
- Transform: value = (value * subject) mod 20201227
- Find loop size by repeatedly transforming until matching public key
- Apply other public key with found loop size

**Key Concepts:** Discrete logarithm (brute force), modular exponentiation

---

## Key Patterns and Techniques

### Parsing Patterns
```elixir
# Blank-line separated groups
input |> String.split("\n\n", trim: true)

# Complex rules with regex
~r/(\w+ \w+) bags contain (.+)\./
|> Regex.run(line, capture: :all_but_first)
```

### Grid Operations
```elixir
# Parse to map
grid = for {row, y} <- Enum.with_index(lines),
           {char, x} <- Enum.with_index(String.graphemes(row)),
           into: %{}, do: {{x, y}, char}

# 8 neighbors
neighbors = for dx <- -1..1, dy <- -1..1, {dx, dy} != {0, 0},
            do: {x + dx, y + dy}
```

### Simulation Patterns
```elixir
# Run until stable
Stream.iterate(initial, &step/1)
|> Enum.reduce_while(nil, fn state, prev ->
  if state == prev, do: {:halt, state}, else: {:cont, state}
end)
```

---

## Recommended Solving Order

### Easy Start (Days 1-6, 8-9, 12, 15, 25)
1. Day 1 - Report Repair (two/three sum)
2. Day 2 - Password Philosophy (parsing, validation)
3. Day 3 - Toboggan Trajectory (grid basics)
4. Day 4 - Passport Processing (parsing, validation)
5. Day 5 - Binary Boarding (binary conversion)
6. Day 6 - Custom Customs (set operations)
7. Day 8 - Handheld Halting (simple VM)
8. Day 9 - Encoding Error (sliding window)
9. Day 12 - Rain Risk (navigation)
10. Day 15 - Rambunctious Recitation (simulation)
11. Day 25 - Combo Breaker (modular arithmetic)

### Moderate Challenges (Days 7, 10-11, 14, 16-18, 21-22, 24)
- Build on basics with more complex logic
- Often require optimization or clever data structures

### Complex Puzzles (Days 13, 19, 20, 23)
- Day 13: Requires CRT or mathematical insight
- Day 19: Grammar parsing with recursion
- Day 20: Multi-step image assembly
- Day 23: Efficient linked list implementation

---

## Resources

- [Hexagonal Grids](https://www.redblobgames.com/grids/hexagons/) - Essential for Day 24
- [Chinese Remainder Theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem) - For Day 13
- [Elixir MapSet](https://hexdocs.pm/elixir/MapSet.html) - Set operations
- [r/adventofcode](https://www.reddit.com/r/adventofcode/) - Community solutions
