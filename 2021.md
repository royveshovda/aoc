# Advent of Code 2021 - Analysis and Progress

## Progress Tracker

| Day | Title | Category | Part 1 | Part 2 |
|-----|-------|----------|--------|--------|
| 1 | Sonar Sweep | Simple | [ ] 1298 | [ ] 1248 |
| 2 | Dive! | Simple | [ ] 2120749 | [ ] 2138382217 |
| 3 | Binary Diagnostic | Moderate | [ ] 4160394 | [ ] TBD |
| 4 | Giant Squid | Moderate | [ ] 10374 | [ ] 24742 |
| 5 | Hydrothermal Venture | Moderate | [ ] 6267 | [ ] 20196 |
| 6 | Lanternfish | Simple | [ ] 374927 | [ ] 1687617803407 |
| 7 | The Treachery of Whales | Simple | [ ] 343468 | [ ] 96086265 |
| 8 | Seven Segment Search | Moderate | [ ] 390 | [ ] 1011785 |
| 9 | Smoke Basin | Moderate | [ ] 512 | [ ] TBD |
| 10 | Syntax Scoring | Simple | [ ] 299793 | [ ] 3654963618 |
| 11 | Dumbo Octopus | Moderate | [ ] 1667 | [ ] 488 |
| 12 | Passage Pathing | Moderate | [ ] 3779 | [ ] 96988 |
| 13 | Transparent Origami | Simple | [ ] 770 | [ ] EPUELPBR |
| 14 | Extended Polymerization | Moderate | [ ] 3259 | [ ] 3459174981021 |
| 15 | Chiton | Moderate | [ ] 602 | [ ] 2935 |
| 16 | Packet Decoder | Complex | [ ] 897 | [ ] 9485076995911 |
| 17 | Trick Shot | Simple | [ ] 8256 | [ ] TBD |
| 18 | Snailfish | Complex | [ ] 3647 | [ ] 4600 |
| 19 | Beacon Scanner | Complex | [ ] TBD | [ ] TBD |
| 20 | Trench Map | Moderate | [ ] TBD | [ ] TBD |
| 21 | Dirac Dice | Moderate | [ ] TBD | [ ] TBD |
| 22 | Reactor Reboot | Complex | [ ] TBD | [ ] TBD |
| 23 | Amphipod | Complex | [ ] TBD | [ ] TBD |
| 24 | Arithmetic Logic Unit | Complex | [ ] TBD | [ ] TBD |
| 25 | Sea Cucumber | Moderate | [ ] TBD | ⭐ |

**Summary:** 7 Simple, 12 Moderate, 6 Complex

---

## 2021 Overview: Submarine Adventure

2021's theme follows your journey in a submarine deep under the ocean to recover Santa's sleigh keys. The puzzles range from simple counting problems to complex 3D transformations and state-space searches. Notable for several mathematically interesting problems including exponential growth simulation, shortest path finding, and game theory.

---

## Day-by-Day Analysis

### Day 1: Sonar Sweep
**Category:** Simple

**Summary:** Count how many times depth measurements increase. Part 1 counts consecutive increases. Part 2 uses a sliding window of 3 measurements.

**Approach:**
- Part 1: Compare adjacent pairs, count when second > first
- Part 2: Sum sliding windows of 3, then compare as in Part 1

**Key Concepts:** List traversal, sliding window

**Elixir Tips:**
```elixir
# Part 1 - using chunk_every
list |> Enum.chunk_every(2, 1, :discard) |> Enum.count(fn [a, b] -> b > a end)

# Part 2 - can compare directly without summing (a+b+c vs b+c+d simplifies to a vs d)
list |> Enum.chunk_every(4, 1, :discard) |> Enum.count(fn [a,_,_,d] -> d > a end)
```

---

### Day 2: Dive!
**Category:** Simple

**Summary:** Navigate submarine with commands. Part 1: Simple position tracking. Part 2: Commands affect "aim" which modifies depth changes.

**Approach:**
- Parse commands: forward X, up X, down X
- Part 1: Track horizontal position and depth directly
- Part 2: Track aim; forward X moves horizontal by X and depth by aim*X

**Key Concepts:** State machine, command parsing

---

### Day 3: Binary Diagnostic
**Category:** Moderate

**Summary:** Analyze binary diagnostic numbers. Part 1: Find most/least common bit in each position. Part 2: Filter by bit criteria until one number remains.

**Approach:**
- Part 1: Count bits in each position, construct gamma (most common) and epsilon (least common)
- Part 2: Iteratively filter numbers by bit criteria (O2: most common, CO2: least common)

**Key Concepts:** Bit manipulation, filtering, frequency counting

**Why Moderate:** Part 2's iterative filtering with changing criteria requires careful implementation.

---

### Day 4: Giant Squid
**Category:** Moderate

**Summary:** Play Bingo with a giant squid. Part 1: Find first winning board. Part 2: Find last winning board.

**Approach:**
- Parse bingo boards and draw numbers
- Mark numbers, check rows/columns for completion
- Part 1: Stop at first winner
- Part 2: Track all winners, identify the last one

**Key Concepts:** 2D grid manipulation, simulation

---

### Day 5: Hydrothermal Venture
**Category:** Moderate

**Summary:** Map hydrothermal vents. Part 1: Horizontal/vertical lines only. Part 2: Include diagonal lines.

**Approach:**
- Parse line segments as {x1,y1} -> {x2,y2}
- Generate all points on each line
- Count points where multiple lines overlap

**Key Concepts:** Line drawing, coordinate geometry, frequency counting

**Elixir Tips:**
```elixir
# Generate points on a line (including diagonals)
for i <- 0..steps do
  {x1 + i * dx, y1 + i * dy}
end
```

---

### Day 6: Lanternfish
**Category:** Simple

**Summary:** Model exponential fish population growth. Part 1: 80 days. Part 2: 256 days.

**Approach:**
- **Key insight:** Track count of fish by timer value (0-8), not individual fish
- Each day: fish at timer 0 spawn new fish at 8, reset to 6; others decrement

**Key Concepts:** Exponential growth, state compression

**Why Simple:** Once you realize to count by timer value, implementation is straightforward.

```elixir
# Track as map: %{timer => count}
# Each day shift counts down, 0s add to both 6 and 8
```

---

### Day 7: The Treachery of Whales
**Category:** Simple

**Summary:** Align crab submarines with minimum fuel. Part 1: Constant fuel cost. Part 2: Increasing fuel cost (1+2+3+...).

**Approach:**
- Part 1: Optimal position is the median (minimizes sum of absolute differences)
- Part 2: Fuel = n*(n+1)/2; try all positions or use calculus (mean ± 0.5)

**Key Concepts:** Optimization, triangular numbers

---

### Day 8: Seven Segment Search
**Category:** Moderate

**Summary:** Decode scrambled seven-segment displays. Part 1: Count unique-length digits (1,4,7,8). Part 2: Decode all outputs.

**Approach:**
- Part 1: Count outputs with lengths 2 (1), 3 (7), 4 (4), or 7 (8)
- Part 2: Deduce segment mapping using set operations:
  - 1 (2 segments) identifies c,f
  - 7 (3 segments) adds a
  - 4 (4 segments) adds b,d
  - Use intersections to distinguish remaining

**Key Concepts:** Set operations, constraint satisfaction, deduction

**Why Moderate:** Part 2 requires careful logical deduction.

---

### Day 9: Smoke Basin
**Category:** Moderate

**Summary:** Find low points and basins in heightmap. Part 1: Sum risk levels of low points. Part 2: Find three largest basins.

**Approach:**
- Part 1: Find cells lower than all 4 neighbors, sum (height + 1)
- Part 2: BFS/flood fill from each low point until hitting 9s; multiply 3 largest

**Key Concepts:** Grid operations, flood fill, BFS

---

### Day 10: Syntax Scoring
**Category:** Simple

**Summary:** Parse bracket sequences. Part 1: Score corrupted lines (wrong closing bracket). Part 2: Score incomplete lines (missing closing brackets).

**Approach:**
- Use a stack: push opening brackets, pop and match closing brackets
- Part 1: First mismatch = corrupted, score by bracket type
- Part 2: Remaining stack items need closing; score right-to-left

**Key Concepts:** Stack-based parsing, bracket matching

```elixir
# Matching pairs
pairs = %{"(" => ")", "[" => "]", "{" => "}", "<" => ">"}
```

---

### Day 11: Dumbo Octopus
**Category:** Moderate

**Summary:** Simulate flashing octopuses on a grid. Part 1: Count flashes after 100 steps. Part 2: Find first synchronized flash.

**Approach:**
- Each step: increment all, then cascade flashes (>9 flashes, affects neighbors)
- Part 1: Count total flashes over 100 steps
- Part 2: Find step where all 100 flash simultaneously

**Key Concepts:** Cellular automaton, cascading effects, simulation

---

### Day 12: Passage Pathing
**Category:** Moderate

**Summary:** Count paths through cave system. Small caves (lowercase) can be visited once. Part 1: Standard rules. Part 2: One small cave can be visited twice.

**Approach:**
- Build graph of cave connections
- DFS counting all paths from start to end
- Part 1: Small caves visited at most once
- Part 2: Track if we've used our "double visit" allowance

**Key Concepts:** Graph traversal, DFS, path counting

**Why Moderate:** Part 2's modified constraint requires careful state tracking.

---

### Day 13: Transparent Origami
**Category:** Simple

**Summary:** Fold a transparent paper with dots. Part 1: Count dots after first fold. Part 2: Read the code after all folds.

**Approach:**
- Track dot positions as set
- Fold: reflect coordinates across fold line, merge
- Part 2: Render final grid to read letters

**Key Concepts:** Coordinate transformation, set operations

---

### Day 14: Extended Polymerization
**Category:** Moderate

**Summary:** Grow polymer by inserting elements between pairs. Part 1: 10 steps. Part 2: 40 steps.

**Approach:**
- **Key insight:** Track pair counts, not the actual string
- Each step: each pair AB→C produces pairs AC and CB
- Count element frequencies from pair counts (each element counted twice except ends)

**Key Concepts:** State compression, exponential growth

**Why Moderate:** Requires insight that tracking pairs avoids exponential memory.

---

### Day 15: Chiton
**Category:** Moderate

**Summary:** Find lowest-risk path through cave. Part 1: Given grid. Part 2: Grid is 5x5 tiles with increasing risk.

**Approach:**
- Dijkstra's algorithm or A* for shortest path
- Part 2: Generate expanded grid (risk wraps 9→1)

**Key Concepts:** Shortest path, Dijkstra's algorithm, priority queue

---

### Day 16: Packet Decoder
**Category:** Complex

**Summary:** Decode nested binary packets. Part 1: Sum version numbers. Part 2: Evaluate expression.

**Approach:**
- Parse hex to binary
- Recursively parse packets: header (version, type), then either literal or operator with sub-packets
- Part 1: Sum all version numbers
- Part 2: Evaluate operators (sum, product, min, max, gt, lt, eq)

**Key Concepts:** Binary parsing, recursive descent, expression evaluation

**Why Complex:** Nested packet structure with two different length modes.

---

### Day 17: Trick Shot
**Category:** Simple (P1) / Moderate (P2)

**Summary:** Fire probe into target area. Part 1: Find maximum height. Part 2: Count all valid initial velocities.

**Approach:**
- Part 1: Math insight - max y velocity is |y_min| - 1, max height is n*(n+1)/2
- Part 2: Brute force all reasonable velocity combinations, simulate trajectories

**Key Concepts:** Physics simulation, triangular numbers, trajectory analysis

---

### Day 18: Snailfish
**Category:** Complex

**Summary:** Snailfish math with nested pairs. Add numbers and reduce (explode pairs at depth 4, split numbers ≥10).

**Approach:**
- Parse nested pairs as tree or list with depth tracking
- Implement explode (depth ≥4) and split (≥10) operations
- Part 1: Sum all, calculate magnitude
- Part 2: Find max magnitude of any two numbers

**Key Concepts:** Tree manipulation, recursive data structures

**Why Complex:** Explode operation requires finding and modifying adjacent regular numbers.

---

### Day 19: Beacon Scanner
**Category:** Complex

**Summary:** Reconstruct 3D beacon map from overlapping scanner observations. Scanners have unknown positions and orientations.

**Approach:**
- For each pair of scanners, try all 24 rotations
- Find translation that makes ≥12 beacons overlap
- Chain transformations to place all beacons in common coordinate system

**Key Concepts:** 3D geometry, rotation matrices, point matching

**Why Complex:** 24 possible orientations, O(n²) beacon matching, complex coordinate transforms.

---

### Day 20: Trench Map
**Category:** Moderate

**Summary:** Image enhancement algorithm. Apply 512-character lookup using 3x3 neighborhoods.

**Approach:**
- Each pixel determined by 9-bit index from 3x3 neighborhood
- **Gotcha:** If index 0 maps to #, infinite space flickers!
- Track the "default" value for infinite space

**Key Concepts:** Image processing, cellular automaton, infinite grid handling

---

### Day 21: Dirac Dice
**Category:** Moderate

**Summary:** Dice game. Part 1: Deterministic die. Part 2: Quantum die splits into 27 universes per turn.

**Approach:**
- Part 1: Simulate with predictable die (1,2,3,4,5...)
- Part 2: Memoized recursion counting universes where each player wins

**Key Concepts:** Simulation, memoization, game theory

---

### Day 22: Reactor Reboot
**Category:** Complex

**Summary:** Toggle 3D cuboid regions on/off. Part 1: Limited region. Part 2: Full input.

**Approach:**
- Part 1: Can brute force for small region (-50..50)
- Part 2: Track non-overlapping cuboids using inclusion-exclusion or octree

**Key Concepts:** 3D geometry, inclusion-exclusion principle, coordinate compression

**Why Complex:** Part 2 requires handling overlapping cuboids efficiently.

---

### Day 23: Amphipod
**Category:** Complex

**Summary:** Move amphipods to destination rooms with minimum energy. Different types have different movement costs.

**Approach:**
- State-space search with Dijkstra or A*
- State: positions of all amphipods
- Generate valid moves respecting movement rules

**Key Concepts:** State-space search, optimization, constraint satisfaction

**Why Complex:** Large state space, complex movement rules, finding optimal solution.

---

### Day 24: Arithmetic Logic Unit
**Category:** Complex

**Summary:** Reverse-engineer ALU program to find valid 14-digit model numbers.

**Approach:**
- Analyze the MONAD program structure (14 similar blocks)
- Each block either pushes or pops from a stack (z register)
- Find constraints that make final z=0

**Key Concepts:** Reverse engineering, program analysis, constraint solving

**Why Complex:** Requires understanding the program's mathematical structure, not just simulation.

---

### Day 25: Sea Cucumber
**Category:** Moderate

**Summary:** Simulate sea cucumber herds moving on toroidal grid. Part 1: Find when movement stops.

**Approach:**
- East-facing move first (simultaneously), then south-facing
- Simulate until no movement occurs

**Key Concepts:** Cellular automaton, simulation, fixed-point detection

---

## Key Patterns and Techniques

### Exponential Growth (Days 6, 14)
```elixir
# Track counts by state, not individual items
state = %{0 => count0, 1 => count1, ...}
```

### Grid Operations (Days 9, 11, 20, 25)
```elixir
# Parse to map
grid = for {row, y} <- Enum.with_index(lines),
           {char, x} <- Enum.with_index(String.graphemes(row)),
           into: %{}, do: {{x, y}, char}

# 4 neighbors
[{0,1}, {0,-1}, {1,0}, {-1,0}]
# 8 neighbors
for dx <- -1..1, dy <- -1..1, {dx,dy} != {0,0}, do: {dx, dy}
```

### Dijkstra's Algorithm (Days 15, 23)
```elixir
# Priority queue with Heap
heap = Heap.new(fn {a,_}, {b,_} -> a < b end)
       |> Heap.push({0, start})
```

### Memoization (Days 12, 21)
```elixir
use Memoize
defmemo solve(state) do
  # recursive solution
end
```

---

## Recommended Solving Order

### Easy Start (Days 1, 2, 6, 7, 10, 13, 17)
1. Day 1 - Sonar Sweep (list comparison)
2. Day 2 - Dive! (command parsing)
3. Day 6 - Lanternfish (state compression)
4. Day 7 - Treachery of Whales (optimization)
5. Day 10 - Syntax Scoring (stack parsing)
6. Day 13 - Transparent Origami (coordinate transforms)
7. Day 17 - Trick Shot (physics/math)

### Moderate Challenges (Days 3-5, 8, 9, 11, 12, 14, 15, 20, 21, 25)
- Build on basics with more complex logic
- Often require optimization or clever data structures

### Complex Puzzles (Days 16, 18, 19, 22, 23, 24)
- Day 16: Binary packet parsing with recursion
- Day 18: Tree manipulation with complex operations
- Day 19: 3D transformations and point matching
- Day 22: 3D cuboid overlap handling
- Day 23: State-space search optimization
- Day 24: Program reverse engineering

---

## Resources

- [Elixir Heap](https://hexdocs.pm/heap/) - Priority queues
- [Memoize](https://hexdocs.pm/memoize/) - Caching expensive computations
- [3D Rotations](https://en.wikipedia.org/wiki/Rotation_matrix) - For Day 19
- [r/adventofcode](https://www.reddit.com/r/adventofcode/) - Community solutions
