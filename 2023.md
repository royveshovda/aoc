# Advent of Code 2023 - Analysis and Progress

## Progress Tracker

| Day | Title | Category | Part 1 | Part 2 |
|-----|-------|----------|--------|--------|
| 1 | Trebuchet?! | Simple | ✅ 54968 | ✅ 54094 |
| 2 | Cube Conundrum | Simple | ✅ 2348 | ✅ 76008 |
| 3 | Gear Ratios | Moderate | ✅ 527364 | ✅ 79026871 |
| 4 | Scratchcards | Simple | ✅ 23847 | ✅ 8570000 |
| 5 | If You Give A Seed A Fertilizer | Moderate | ✅ 313045984 | ✅ 20283860 |
| 6 | Wait For It | Simple | ✅ 4568778 | ✅ 28973936 |
| 7 | Camel Cards | Moderate | ✅ 246912307 | ✅ 246894760 |
| 8 | Haunted Wasteland | Moderate | ✅ 17287 | ✅ 18625484023687 |
| 9 | Mirage Maintenance | Simple | ✅ 1731106378 | ✅ 1087 |
| 10 | Pipe Maze | Complex | ✅ 6875 | ✅ 471 |
| 11 | Cosmic Expansion | Simple | ✅ 9795148 | ✅ 650672493820 |
| 12 | Hot Springs | Complex | ✅ 8180 | ✅ 620189727003627 |
| 13 | Point of Incidence | Moderate | ✅ 37975 | ✅ 32497 |
| 14 | Parabolic Reflector Dish | Moderate | ✅ 102497 | ✅ 105008 |
| 15 | Lens Library | Simple | ✅ 505379 | ✅ 263211 |
| 16 | The Floor Will Be Lava | Moderate | ✅ 7608 | ✅ 8221 |
| 17 | Clumsy Crucible | Complex | ✅ 724 | ✅ 877 |
| 18 | Lavaduct Lagoon | Moderate | ✅ 56923 | ✅ 66296566363189 |
| 19 | Aplenty | Moderate | ✅ 434147 | ✅ 136146366355609 |
| 20 | Pulse Propagation | Complex | ✅ 747304011 | ✅ 220366255099387 |
| 21 | Step Counter | Complex | ✅ 3795 | ✅ 630129824772393 |
| 22 | Sand Slabs | Moderate | ✅ 437 | ✅ 42561 |
| 23 | A Long Walk | Complex | ✅ 2218 | ✅ 6674 |
| 24 | Never Tell Me The Odds | Complex | ✅ 20847 | ✅ 908621716620524 |
| 25 | Snowverload | Complex | ✅ 544523 | ⭐ |

**Summary:** 7 Simple, 10 Moderate, 8 Complex - **ALL 25 DAYS COMPLETE! ✅**

**Total Runtime:** ~47 seconds

---

## 2023 Overview: Fixing Snow Production

2023's theme follows your journey to fix global snow production, traveling through various islands and encountering weather machines, gardens, and mysterious devices. This year features particularly challenging problems with several Complex days requiring advanced algorithms.

---

## Day-by-Day Analysis

### Day 1: Trebuchet?!
**Category:** Simple

**Summary:** Extract calibration values from strings by finding first and last digits. Part 1 uses only numeric digits. Part 2 includes spelled-out numbers ("one", "two", etc.).

**Approach:**
- Part 1: Filter for digit characters, take first and last, combine to two-digit number
- Part 2: Handle overlapping spelled numbers (e.g., "twone" = 2, 1)

**Key Concepts:** String parsing, regex

**Gotcha:** Part 2 - spelled numbers can overlap ("twone", "eighthree", "sevenine")

---

### Day 2: Cube Conundrum
**Category:** Simple

**Summary:** Parse game records showing cubes drawn from a bag. Part 1: Find games possible with limited cubes. Part 2: Find minimum cubes needed per game, calculate "power".

**Approach:**
- Parse: Game ID and sets of color:count pairs
- Part 1: Check if any draw exceeds 12 red, 13 green, 14 blue
- Part 2: Find max of each color across all draws, multiply together

**Key Concepts:** Parsing, max aggregation

---

### Day 3: Gear Ratios
**Category:** Moderate

**Summary:** Engine schematic with numbers and symbols. Part 1: Sum numbers adjacent to any symbol. Part 2: Find "gears" (* symbols adjacent to exactly 2 numbers), sum products.

**Approach:**
- Parse grid, identify number positions (spans multiple columns)
- Part 1: Check if any digit of a number is adjacent to a symbol
- Part 2: For each *, find all adjacent numbers, multiply if exactly 2

**Key Concepts:** Grid parsing, adjacency, number extraction

**Why Moderate:** Numbers span multiple cells, need careful position tracking.

---

### Day 4: Scratchcards
**Category:** Simple

**Summary:** Scratchcards with winning numbers and your numbers. Part 1: Score based on matches (first match = 1 point, doubles thereafter). Part 2: Win copies of subsequent cards based on matches.

**Approach:**
- Parse each card's winning numbers and your numbers
- Part 1: Count matches, score = 2^(matches-1) if matches > 0
- Part 2: Track card counts, cascade wins to following cards

**Key Concepts:** Set intersection, cascading updates

---

### Day 5: If You Give A Seed A Fertilizer
**Category:** Complex

**Summary:** Map seeds through multiple transformation stages to locations. Part 1: Direct seed-to-location mapping. Part 2: Seeds are ranges (pairs of start, length).

**Approach:**
- Parse seeds and mapping stages
- Part 1: Transform each seed through all stages
- Part 2: Work with ranges, split at mapping boundaries

**Key Concepts:** Range transformations, interval arithmetic

**Why Complex:** Part 2 requires handling billions of seeds via range operations, not brute force.

---

### Day 6: Wait For It
**Category:** Simple

**Summary:** Boat races - hold button to charge, then race. Distance = hold_time * (race_time - hold_time). Part 1: Multiple races. Part 2: Single race (concatenate numbers).

**Approach:**
- Distance formula: d = t * (T - t) where T = race time, t = hold time
- Count integer t values where d > record
- Can solve with quadratic formula: t² - Tt + record < 0

**Key Concepts:** Quadratic equations, brute force or math

---

### Day 7: Camel Cards
**Category:** Moderate

**Summary:** Poker-like card game ranking. Part 1: Standard ranking. Part 2: J becomes Joker (wild card, weakest individually).

**Approach:**
- Classify hand type (five-of-a-kind, four-of-a-kind, etc.)
- Sort by type, then by card values left-to-right
- Part 2: J becomes wild - try all possibilities to find best hand type

**Key Concepts:** Sorting, classification, card game logic

**Why Moderate:** Part 2's wild card logic requires considering all substitutions.

---

### Day 8: Haunted Wasteland
**Category:** Moderate

**Summary:** Network navigation with L/R instructions. Part 1: Navigate AAA to ZZZ. Part 2: Multiple simultaneous paths (all **A to all **Z).

**Approach:**
- Part 1: Follow instructions from AAA until reaching ZZZ
- Part 2: Find cycle length for each starting node, compute LCM

**Key Concepts:** Graph traversal, cycle detection, LCM

**Why Moderate:** Part 2 requires recognizing the LCM pattern.

---

### Day 9: Mirage Maintenance
**Category:** Simple

**Summary:** Predict next value in sequences using differences. Part 1: Extrapolate forward. Part 2: Extrapolate backward.

**Approach:**
- Generate difference sequences until all zeros
- Part 1: Add from bottom up to find next value
- Part 2: Subtract from bottom up to find previous value

**Key Concepts:** Recursion, difference sequences

---

### Day 10: Pipe Maze
**Category:** Complex

**Summary:** Find loop in pipe network from starting position. Part 1: Find farthest point in loop. Part 2: Count tiles enclosed by loop.

**Approach:**
- Part 1: BFS/DFS to find loop, farthest = length / 2
- Part 2: Ray casting or flood fill with proper handling of pipe crossings

**Key Concepts:** Graph traversal, point-in-polygon, ray casting

**Why Complex:** Part 2's enclosed area calculation with pipes is tricky.

---

### Day 11: Cosmic Expansion
**Category:** Simple

**Summary:** Galaxy map with expansion. Empty rows/columns expand. Find sum of shortest paths between all galaxy pairs.

**Approach:**
- Identify empty rows and columns
- For each galaxy pair, calculate Manhattan distance accounting for expansions
- Part 2: Expansion factor becomes 1,000,000

**Key Concepts:** Manhattan distance, coordinate transformation

---

### Day 12: Hot Springs
**Category:** Complex

**Summary:** Match damaged spring patterns. Given pattern with unknowns (?) and group sizes, count valid arrangements. Part 2: Unfold 5x with ? separator.

**Approach:**
- Dynamic programming with memoization
- State: (position in pattern, position in groups, current run length)
- Part 2: Same logic but 5x input size - must be efficient

**Key Concepts:** Dynamic programming, memoization, pattern matching

**Why Complex:** Exponential possibilities without DP; Part 2 makes brute force impossible.

---

### Day 13: Point of Incidence
**Category:** Moderate

**Summary:** Find reflection lines in patterns. Part 1: Perfect reflection. Part 2: Find reflection with exactly one smudge (one different cell).

**Approach:**
- Check all possible vertical and horizontal reflection lines
- Part 1: Find line where both sides match perfectly
- Part 2: Find line where sides differ by exactly one cell

**Key Concepts:** Symmetry detection, string comparison

---

### Day 14: Parabolic Reflector Dish
**Category:** Moderate

**Summary:** Roll rocks on tilting platform. Part 1: Tilt north. Part 2: Cycle (N, W, S, E) 1 billion times.

**Approach:**
- Part 1: Simulate rolling rocks north
- Part 2: Detect cycle, skip to target iteration

**Key Concepts:** Simulation, cycle detection

**Why Moderate:** Part 2 requires cycle detection for 1B iterations.

---

### Day 15: Lens Library
**Category:** Simple

**Summary:** Hash algorithm and lens boxes. Part 1: Sum HASH values. Part 2: Follow lens placement instructions, calculate focusing power.

**Approach:**
- HASH: value = ((value + ASCII) * 17) % 256
- Part 1: Apply HASH to each comma-separated step
- Part 2: Manage 256 boxes with ordered lists of lenses

**Key Concepts:** Hashing, linked lists/ordered maps

---

### Day 16: The Floor Will Be Lava
**Category:** Moderate

**Summary:** Light beam simulation through mirrors and splitters. Part 1: Count energized tiles from one entry. Part 2: Find entry point that energizes most tiles.

**Approach:**
- Simulate beam(s) with BFS/DFS, tracking visited states (position + direction)
- Handle mirrors (/ \) and splitters (| -)
- Part 2: Try all edge positions and directions

**Key Concepts:** Simulation, BFS, state tracking

---

### Day 17: Clumsy Crucible
**Category:** Complex

**Summary:** Pathfinding with movement constraints - can't go straight more than 3 blocks. Part 2: "Ultra crucible" - must go 4-10 blocks before turning.

**Approach:**
- Dijkstra with state = (position, direction, consecutive_count)
- Part 1: Max 3 consecutive same direction
- Part 2: Min 4, max 10 consecutive before turn

**Key Concepts:** Dijkstra, constrained pathfinding

**Why Complex:** Standard pathfinding won't work; state must include movement history.

---

### Day 18: Lavaduct Lagoon
**Category:** Moderate

**Summary:** Dig a trench following instructions, find area. Part 1: Simple instructions. Part 2: Instructions encoded in hex color (huge numbers).

**Approach:**
- Part 1: Can flood fill or use Shoelace formula
- Part 2: Must use Shoelace formula + Pick's theorem (numbers too large for grid)

**Key Concepts:** Shoelace formula, Pick's theorem, polygon area

---

### Day 19: Aplenty
**Category:** Moderate

**Summary:** Rule-based part sorting with workflows. Part 1: Process parts through rules. Part 2: Count all accepted combinations in ranges 1-4000.

**Approach:**
- Parse workflows and rules
- Part 1: Simulate each part through workflows
- Part 2: Track ranges, split at rule boundaries, count accepted

**Key Concepts:** Rule processing, range splitting

---

### Day 20: Pulse Propagation
**Category:** Complex

**Summary:** Simulate pulse propagation through flip-flops and conjunction modules. Part 1: Count pulses after 1000 button presses. Part 2: Find when rx receives low pulse.

**Approach:**
- Part 1: Simulate with queue, count low/high pulses
- Part 2: Analyze circuit structure, find cycle lengths for inputs to rx's parent

**Key Concepts:** State machine simulation, cycle detection, LCM

**Why Complex:** Part 2 requires reverse-engineering the circuit.

---

### Day 21: Step Counter
**Category:** Complex

**Summary:** Count reachable garden plots in exactly N steps. Part 1: 64 steps, finite grid. Part 2: 26501365 steps, infinite repeating grid.

**Approach:**
- Part 1: BFS, track positions reachable in exactly 64 steps
- Part 2: Exploit grid properties (131x131, diamond pattern), quadratic extrapolation

**Key Concepts:** BFS, pattern recognition, quadratic fitting

**Why Complex:** Part 2 requires mathematical insight about infinite grid behavior.

---

### Day 22: Sand Slabs
**Category:** Moderate

**Summary:** 3D falling blocks. Part 1: Count blocks safe to disintegrate. Part 2: Sum of blocks that would fall for each disintegration.

**Approach:**
- Simulate falling to settle blocks
- Build support graph (which blocks support which)
- Part 1: Safe if all supported blocks have other supports
- Part 2: BFS to count chain reaction for each block

**Key Concepts:** 3D simulation, dependency graphs

---

### Day 23: A Long Walk
**Category:** Complex

**Summary:** Longest path through hiking trails. Part 1: Slopes force direction. Part 2: Slopes become bidirectional.

**Approach:**
- Part 1: DFS with slope constraints
- Part 2: Contract graph to junction points, brute force longest path

**Key Concepts:** Longest path (NP-hard), graph contraction, DFS

**Why Complex:** Longest path is NP-hard; Part 2 requires optimization.

---

### Day 24: Never Tell Me The Odds
**Category:** Complex

**Summary:** Hailstones with positions and velocities. Part 1: Count 2D future path intersections in range. Part 2: Find rock position/velocity to hit all hailstones.

**Approach:**
- Part 1: Line intersection math (2D, ignoring Z)
- Part 2: Solve system of equations (6 unknowns: rock px, py, pz, vx, vy, vz)

**Key Concepts:** Linear algebra, system of equations, possibly Z3 solver

**Why Complex:** Part 2 requires solving non-linear system or clever algebra.

---

### Day 25: Snowverload
**Category:** Moderate

**Summary:** Find 3 edges to cut to split graph into two components. Multiply component sizes.

**Approach:**
- Use minimum cut algorithm (Karger's, Stoer-Wagner, or max-flow based)
- Or: visualize graph, identify bridge edges manually

**Key Concepts:** Minimum cut, graph connectivity

---

## Key Patterns and Techniques

### Parsing Patterns
```elixir
# Lines
input |> String.split("\n", trim: true)

# Sections separated by blank lines
input |> String.split("\n\n", trim: true)

# Numbers from string
~r/-?\d+/ |> Regex.scan(line) |> List.flatten() |> Enum.map(&String.to_integer/1)
```

### Grid Operations
```elixir
# Parse to coordinate map
grid = for {row, y} <- Enum.with_index(lines),
           {char, x} <- Enum.with_index(String.graphemes(row)),
           into: %{}, do: {{x, y}, char}

# 4-direction neighbors
[{0, -1}, {0, 1}, {-1, 0}, {1, 0}]
|> Enum.map(fn {dx, dy} -> {x + dx, y + dy} end)
```

### Common Algorithms
```elixir
# Cycle detection for large iterations
defp find_cycle(state, seen, iteration) do
  if Map.has_key?(seen, state) do
    {Map.get(seen, state), iteration}
  else
    find_cycle(next_state(state), Map.put(seen, state, iteration), iteration + 1)
  end
end

# LCM for multiple values
defp lcm(a, b), do: div(a * b, Integer.gcd(a, b))
defp lcm_list(list), do: Enum.reduce(list, 1, &lcm/2)
```

---

## Recommended Solving Order

### Simple Days (1, 2, 4, 6, 9, 11, 15)
Start here to warm up with parsing and straightforward logic.

### Moderate Days (3, 7, 8, 13, 14, 16, 18, 19, 22, 25)
Build complexity with grid operations, cycle detection, and graph algorithms.

### Complex Days (5, 10, 12, 17, 20, 21, 23, 24)
Advanced algorithms required - DP, constrained pathfinding, mathematical insights.

---

## Resources

- [Shoelace Formula](https://en.wikipedia.org/wiki/Shoelace_formula) - For polygon area (Day 18)
- [Pick's Theorem](https://en.wikipedia.org/wiki/Pick%27s_theorem) - Area from boundary/interior points
- [Dijkstra's Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) - For Day 17
- [r/adventofcode](https://www.reddit.com/r/adventofcode/) - Community solutions
